# Тема занятия
## 1. Повторение одномерных динамических массивов

  **Одномерные динамические массивы** в C++ — это массивы, размер которых может изменяться во время выполнения программы.\
  В отличие от статических массивов, размер которых должен быть известен на этапе компиляции, динамические массивы позволяют гибко управлять памятью.\
  Они создаются в динамической памяти (куче) с помощью операторов *new* и *delete*

  **Создание одномерного динамического массива**\
  Для создания динамического массива используется оператор new. Он выделяет память в куче и возвращает указатель на первый элемент массива.
  ```
  тип* имя_указателя = new тип[размер];
  ```
  ```
  int* arr = new int[10];  // Создаём массив из 10 целых чисел
  ```

  **Освобождение памяти**\
  После использования динамического массива память нужно освободить с помощью оператора delete[].\
  Если этого не сделать, произойдёт утечка памяти.

  ```
  delete[] имя_указателя;
  ```

  ```
  delete[] arr;  // Освобождаем память
  ```

  ### Преимущества динамических массивов
  
   - Гибкость:\
   Размер массива может определяться во время выполнения программы.

  - Эффективное использование памяти:\
  Память выделяется только тогда, когда она нужна, и освобождается, когда больше не требуется.

  ### Недостатки динамических массивов
  
  - Управление памятью:\
  Необходимо вручную освобождать память с помощью delete[], иначе произойдёт утечка памяти.

  - Отсутствие информации о размере:\
  В отличие от статических массивов, динамический массив не хранит информацию о своём размере. Размер нужно хранить отдельно.

  - Опасность утечек памяти и ошибок:
  Если забыть освободить память или использовать неправильный оператор (delete вместо delete[]), это приведёт к ошибкам.

## 2. Повторение и доработка многомерных динамических массивов

  **Двумерные динамические массивы** в C++ — это массивы, которые представляют собой таблицу (матрицу) с строками и столбцами,\
  размер которых может изменяться во время выполнения программы. Они создаются в динамической памяти (куче) с использованием указателей и операторов *new* и *delete*.

 **Создание двумерного динамического массива**\
 Для создания двумерного динамического массива используется двойной указатель (тип**).\
 Сначала выделяется память для массива указателей на строки, а затем для каждой строки выделяется память для элементов.
 ```
 тип** имя_указателя = new тип*[количество_строк];
 for (int i = 0; i < количество_строк; ++i) {
    имя_указателя[i] = new тип[количество_столбцов];
 }
 ```

 ```
 int rows = 3, cols = 4;
 int** arr = new int*[rows];  // Выделяем память для строк
 for (int i = 0; i < rows; ++i) {
    arr[i] = new int[cols];  // Выделяем память для столбцов
 }
 ```

 **Освобождение памяти**\
 После использования двумерного динамического массива память нужно освободить в обратном порядке: сначала освобождаются строки, а затем массив указателей.

 ```
 for (int i = 0; i < количество_строк; ++i) {
    delete[] имя_указателя[i];  // Освобождаем память для каждой строки
 }
 delete[] имя_указателя;  // Освобождаем память для массива указателей
```
```
 for (int i = 0; i < rows; ++i) {
    delete[] arr[i];  // Освобождаем память для каждой строки
 }
 delete[] arr;  // Освобождаем память для массива указателей
```

 **Дополнительные недостатки двумерных динамических массивов**\ 
  - Медленный доступ к элементам:
  Из-за фрагментации памяти доступ к элементам может быть медленнее, чем в статических массивах.

## 3. Рекурсия. Как пример (Ханойские башни)
   
  **Рекурсия** — это подход в программировании, при котором функция вызывает саму себя для решения задачи, разбивая её на более мелкие подзадачи того же типа.\
  Она особенно полезна для задач, которые можно разделить на повторяющиеся шаги.
   
  ### Основные компоненты рекурсии
  
   - Базовый случай — условие, при котором рекурсия останавливается. Без него возникнет бесконечный цикл.

   - Рекурсивный случай — шаг, на котором функция вызывает себя с изменёнными параметрами.
   
  ### Плюсы и минусы рекурсии
  
  ✅ Плюсы:

   - Упрощает код для задач с вложенной структурой (обход деревьев, графов, анализ директорий).

   - Позволяет элегантно решать задачи, которые естественно описываются рекурсивно.

  ❌ Минусы:

   - Риск переполнения стека вызовов (при большой глубине рекурсии).

   - Неэффективность по памяти и времени в некоторых случаях (например, числа Фибоначчи).

  ### Рекурсия vs Итерация
    
   - Рекурсия часто делает код лаконичнее, но может быть менее эффективной.

   - Итерация (циклы) обычно экономит память и работает быстрее.
   
  ### Советы по использованию
  
   - Всегда определяйте базовый случай.

   - Убедитесь, что рекурсия сходится (параметры движутся к базовому случаю).

   - Для оптимизации используйте мемоизацию (сохранение результатов дорогих вычислений).

   - Внимание к глубине рекурсии - она ограничена.

  ### Хвостовая рекурсия

  Особый вид рекурсии, при котором рекурсивный вызов функции является последней операцией перед возвратом результата.\
  Это позволяет оптимизировать использование памяти и избежать переполнения стека вызовов, так как компиляторы или интерпретаторы могут преобразовать хвостовую рекурсию в итерацию.

  ## Особенности хвостовой рекурсии
  
   **Рекурсивный вызов — последняя операция:**
  
   В хвостовой рекурсии результат рекурсивного вызова сразу возвращается без дополнительных вычислений.

   **Оптимизация:**
  
   Некоторые языки программирования (например, Haskell, Scala, Erlang) поддерживают оптимизацию хвостовой рекурсии.\
   Это означает, что вместо создания нового кадра стека для каждого вызова, компилятор заменяет рекурсию на цикл, что экономит память.   

  ### Как работает хвостовая рекурсия

   - В хвостовой рекурсии используется аккумулятор — дополнительный параметр, который накапливает результат.
   - На каждом шаге рекурсии аккумулятор обновляется, а параметр, управляющий рекурсией (например, n), уменьшается.
   - Когда достигается базовый случай, аккумулятор возвращается как результат.  

  ### Преимущества хвостовой рекурсии

   - Экономия памяти:\
   При оптимизации хвостовой рекурсии не создаются новые кадры стека, что предотвращает переполнение стека.

   - Производительность:\
   Преобразование в итерацию делает выполнение быстрее, так как отсутствуют накладные расходы на вызовы функций.

  ### Недостатки хвостовой рекурсии

   - Не везде поддерживается:\
   Например, в Python хвостовая рекурсия не оптимизируется, поэтому её использование не даёт преимуществ.

 - Сложность восприятия:\
   Код с хвостовой рекурсией может быть менее интуитивным, особенно для новичков.


  **C++** не гарантирует оптимизацию хвостовой рекурсии на уровне стандарта языка,\
  но многие современные компиляторы (например, GCC, Clang) могут выполнять такую оптимизацию при определённых условиях.\
  Это называется **Tail Call Optimization (TCO)**.\ 
  Если вы хотите быть уверены в отсутствии переполнения стека, лучше использовать итерацию или явно проверять, поддерживает ли ваш компилятор TCO.

  ### Как работает оптимизация хвостовой рекурсии в C++?

   - Условия для оптимизации:
     - Рекурсивный вызов должен быть последней операцией в функции.
     - Не должно быть необходимости сохранять состояние текущего вызова (например, выполнять дополнительные вычисления после рекурсивного вызова).
     - Компилятор должен поддерживать TCO и быть настроен на выполнение этой оптимизации.
 
   - Результат оптимизации:
     - Вместо создания нового кадра стека для каждого вызова, компилятор заменяет рекурсивный вызов на переход (аналог цикла).
     - Это предотвращает переполнение стека и экономит память.

  ### Ограничения
  
   - Не гарантируется стандартом:\
   Оптимизация хвостовой рекурсии зависит от компилятора и его настроек.\
   Если компилятор не поддерживает TCO или она не включена, хвостовая рекурсия будет работать как обычная рекурсия.

   - Сложные случаи:\
   Если в функции есть дополнительные операции после рекурсивного вызова, оптимизация может не сработать.


# Домашнее задание

  ##  Задание 1

  Написать рекурсивную функцию, которая выводит N звезд в ряд, число N задает пользователь.\
  Проиллюстрируйте работу функции примером.

  ##  Задание 2

  Написать рекурсивную функцию, которая вычисляет сумму всех чисел в диапазоне от a до b.\
  Пользователь вводит a и b. Проиллюстрируйте работу функции примером.

  ##  Задание 3

  Дана шахматная доска размером 6х6 и шахматный конь.\
  Программа должна запросить у пользователя координаты клетки поля и поставить туда коня.\
  Задача программы найти и вывести путь коня, при котором он обойдет все клетки доски, становясь в каждую клетку только один раз.\
  В программе необходимо использовать рекурсию.
  
